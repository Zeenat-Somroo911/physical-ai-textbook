"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[9762],{6922:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"module-01-ros2/python-rclpy","title":"Chapter 4: Python rclpy Deep Dive","description":"Introduction","source":"@site/docs/module-01-ros2/04-python-rclpy.md","sourceDirName":"module-01-ros2","slug":"/module-01-ros2/python-rclpy","permalink":"/physical-ai-textbook/docs/module-01-ros2/python-rclpy","draft":false,"unlisted":false,"editUrl":"https://github.com/Zeenat-Somroo911/physical-ai-textbook/edit/main/docs/module-01-ros2/04-python-rclpy.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Services and Actions","permalink":"/physical-ai-textbook/docs/module-01-ros2/services-actions"},"next":{"title":"Chapter 5: URDF Basics","permalink":"/physical-ai-textbook/docs/module-01-ros2/urdf-basics"}}');var l=n(4848),t=n(8453);const s={sidebar_position:4},i="Chapter 4: Python rclpy Deep Dive",o={},c=[{value:"Introduction",id:"introduction",level:2},{value:"rclpy Library Overview",id:"rclpy-library-overview",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Import Structure",id:"import-structure",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:2},{value:"Lifecycle States",id:"lifecycle-states",level:3},{value:"Basic Node Lifecycle",id:"basic-node-lifecycle",level:3},{value:"Standard Node Lifecycle",id:"standard-node-lifecycle",level:3},{value:"Timers and Callbacks",id:"timers-and-callbacks",level:2},{value:"Creating Timers",id:"creating-timers",level:3},{value:"Timer Types",id:"timer-types",level:3},{value:"Multiple Timers",id:"multiple-timers",level:3},{value:"Timer Management",id:"timer-management",level:3},{value:"Callback Functions",id:"callback-functions",level:2},{value:"Callback Execution",id:"callback-execution",level:3},{value:"Callback Best Practices",id:"callback-best-practices",level:3},{value:"Callback Threading",id:"callback-threading",level:3},{value:"Parameters",id:"parameters",level:2},{value:"Declaring Parameters",id:"declaring-parameters",level:3},{value:"Parameter Descriptors",id:"parameter-descriptors",level:3},{value:"Parameter Constraints",id:"parameter-constraints",level:3},{value:"Setting Parameters at Runtime",id:"setting-parameters-at-runtime",level:3},{value:"Executors",id:"executors",level:2},{value:"Single-Threaded Executor",id:"single-threaded-executor",level:3},{value:"Multi-Threaded Executor",id:"multi-threaded-executor",level:3},{value:"Custom Executor",id:"custom-executor",level:3},{value:"Complete Working Examples",id:"complete-working-examples",level:2},{value:"Example 1: Sensor Fusion Node",id:"example-1-sensor-fusion-node",level:3},{value:"Example 2: State Machine Node",id:"example-2-state-machine-node",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Logging Configuration",id:"logging-configuration",level:3},{value:"Clock and Time",id:"clock-and-time",level:3},{value:"Node Namespaces",id:"node-namespaces",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Errors and Solutions",id:"common-errors-and-solutions",level:2},{value:"Error 1: &quot;rclpy.init() not called&quot;",id:"error-1-rclpyinit-not-called",level:3},{value:"Error 2: &quot;Timer callback blocking&quot;",id:"error-2-timer-callback-blocking",level:3},{value:"Error 3: &quot;Parameter not declared&quot;",id:"error-3-parameter-not-declared",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Parameter-Driven Node",id:"exercise-1-parameter-driven-node",level:3},{value:"Exercise 2: Multi-Timer Coordination",id:"exercise-2-multi-timer-coordination",level:3},{value:"Exercise 3: Callback Queue Management",id:"exercise-3-callback-queue-management",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(r.header,{children:(0,l.jsx)(r.h1,{id:"chapter-4-python-rclpy-deep-dive",children:"Chapter 4: Python rclpy Deep Dive"})}),"\n",(0,l.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,l.jsxs)(r.p,{children:["The ",(0,l.jsx)(r.code,{children:"rclpy"})," library is the Python client library for ROS 2. This chapter provides a comprehensive guide to mastering rclpy, covering node lifecycle, timers, callbacks, parameters, and advanced features."]}),"\n",(0,l.jsx)(r.h2,{id:"rclpy-library-overview",children:"rclpy Library Overview"}),"\n",(0,l.jsx)(r.h3,{id:"core-components",children:"Core Components"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-mermaid",children:"graph TB\r\n    A[rclpy] --\x3e B[Node]\r\n    A --\x3e C[Publisher]\r\n    A --\x3e D[Subscriber]\r\n    A --\x3e E[Service]\r\n    A --\x3e F[Action]\r\n    A --\x3e G[Timer]\r\n    A --\x3e H[Parameter]\r\n    A --\x3e I[Executor]\r\n    \r\n    style A fill:#e1f5ff\r\n    style B fill:#b3e5fc\n"})}),"\n",(0,l.jsx)(r.h3,{id:"import-structure",children:"Import Structure"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.qos import QoSProfile\r\nfrom rclpy.parameter import Parameter\r\nfrom rclpy.executors import SingleThreadedExecutor\n"})}),"\n",(0,l.jsx)(r.h2,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,l.jsx)(r.p,{children:"Understanding the node lifecycle is crucial for proper resource management."}),"\n",(0,l.jsx)(r.h3,{id:"lifecycle-states",children:"Lifecycle States"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-mermaid",children:"stateDiagram-v2\r\n    [*] --\x3e Unconfigured\r\n    Unconfigured --\x3e Inactive: configure()\r\n    Inactive --\x3e Active: activate()\r\n    Active --\x3e Inactive: deactivate()\r\n    Inactive --\x3e Unconfigured: cleanup()\r\n    Unconfigured --\x3e [*]: shutdown()\r\n    Inactive --\x3e [*]: shutdown()\r\n    Active --\x3e [*]: shutdown()\n"})}),"\n",(0,l.jsx)(r.h3,{id:"basic-node-lifecycle",children:"Basic Node Lifecycle"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass LifecycleNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'lifecycle_node\')\r\n        self.get_logger().info(\'Node created (Unconfigured)\')\r\n    \r\n    def configure(self):\r\n        """Called when node is configured."""\r\n        self.get_logger().info(\'Node configured (Inactive)\')\r\n        return True\r\n    \r\n    def activate(self):\r\n        """Called when node is activated."""\r\n        self.get_logger().info(\'Node activated (Active)\')\r\n        return True\r\n    \r\n    def deactivate(self):\r\n        """Called when node is deactivated."""\r\n        self.get_logger().info(\'Node deactivated (Inactive)\')\r\n        return True\r\n    \r\n    def cleanup(self):\r\n        """Called when node is cleaned up."""\r\n        self.get_logger().info(\'Node cleaned up (Unconfigured)\')\r\n        return True\r\n    \r\n    def shutdown(self):\r\n        """Called when node is shut down."""\r\n        self.get_logger().info(\'Node shut down\')\r\n        return True\n'})}),"\n",(0,l.jsx)(r.h3,{id:"standard-node-lifecycle",children:"Standard Node Lifecycle"}),"\n",(0,l.jsx)(r.p,{children:"For standard nodes (non-lifecycle), the lifecycle is simpler:"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"def main(args=None):\r\n    # 1. Initialize ROS 2\r\n    rclpy.init(args=args)\r\n    \r\n    # 2. Create node\r\n    node = MyNode()\r\n    \r\n    try:\r\n        # 3. Spin (keep node alive)\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        # 4. Handle interruption\r\n        node.get_logger().info('Interrupted')\r\n    finally:\r\n        # 5. Cleanup\r\n        node.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,l.jsx)(r.h2,{id:"timers-and-callbacks",children:"Timers and Callbacks"}),"\n",(0,l.jsx)(r.p,{children:"Timers are essential for periodic operations in ROS 2 nodes."}),"\n",(0,l.jsx)(r.h3,{id:"creating-timers",children:"Creating Timers"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'class TimerNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'timer_node\')\r\n        \r\n        # Create timer with period and callback\r\n        self.timer = self.create_timer(\r\n            1.0,  # Period in seconds\r\n            self.timer_callback\r\n        )\r\n    \r\n    def timer_callback(self):\r\n        """Called periodically by timer."""\r\n        self.get_logger().info(\'Timer callback executed\')\n'})}),"\n",(0,l.jsx)(r.h3,{id:"timer-types",children:"Timer Types"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"# Wall timer (real-time)\r\nself.wall_timer = self.create_timer(1.0, self.wall_callback)\r\n\r\n# Rate-based timer\r\nimport time\r\nlast_time = time.time()\r\nrate = 10.0  # Hz\r\n\r\ndef rate_callback(self):\r\n    current_time = time.time()\r\n    if current_time - last_time >= 1.0 / rate:\r\n        # Execute callback\r\n        self.do_work()\r\n        last_time = current_time\n"})}),"\n",(0,l.jsx)(r.h3,{id:"multiple-timers",children:"Multiple Timers"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'class MultiTimerNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'multi_timer_node\')\r\n        \r\n        # Fast timer (10 Hz)\r\n        self.fast_timer = self.create_timer(0.1, self.fast_callback)\r\n        \r\n        # Slow timer (1 Hz)\r\n        self.slow_timer = self.create_timer(1.0, self.slow_callback)\r\n    \r\n    def fast_callback(self):\r\n        """Called 10 times per second."""\r\n        self.get_logger().debug(\'Fast callback\')\r\n    \r\n    def slow_callback(self):\r\n        """Called once per second."""\r\n        self.get_logger().info(\'Slow callback\')\n'})}),"\n",(0,l.jsx)(r.h3,{id:"timer-management",children:"Timer Management"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'class ManagedTimerNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'managed_timer_node\')\r\n        \r\n        self.timer = self.create_timer(1.0, self.timer_callback)\r\n        self.timer_running = True\r\n    \r\n    def timer_callback(self):\r\n        if not self.timer_running:\r\n            return\r\n        \r\n        self.get_logger().info(\'Timer running\')\r\n    \r\n    def stop_timer(self):\r\n        """Stop the timer."""\r\n        self.timer_running = False\r\n        self.timer.cancel()\r\n    \r\n    def restart_timer(self):\r\n        """Restart the timer."""\r\n        self.timer_running = True\r\n        self.timer = self.create_timer(1.0, self.timer_callback)\n'})}),"\n",(0,l.jsx)(r.h2,{id:"callback-functions",children:"Callback Functions"}),"\n",(0,l.jsx)(r.p,{children:"Callbacks are functions called in response to events. Understanding callback behavior is crucial."}),"\n",(0,l.jsx)(r.h3,{id:"callback-execution",children:"Callback Execution"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'class CallbackNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'callback_node\')\r\n        \r\n        # Subscription callback\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            \'topic\',\r\n            self.subscription_callback,\r\n            10\r\n        )\r\n        \r\n        # Service callback\r\n        self.service = self.create_service(\r\n            MyService,\r\n            \'service\',\r\n            self.service_callback\r\n        )\r\n        \r\n        # Timer callback\r\n        self.timer = self.create_timer(1.0, self.timer_callback)\r\n    \r\n    def subscription_callback(self, msg):\r\n        """Called when message received."""\r\n        self.get_logger().info(f\'Received: {msg.data}\')\r\n    \r\n    def service_callback(self, request, response):\r\n        """Called when service requested."""\r\n        response.result = request.input * 2\r\n        return response\r\n    \r\n    def timer_callback(self):\r\n        """Called periodically."""\r\n        self.get_logger().info(\'Timer tick\')\n'})}),"\n",(0,l.jsx)(r.h3,{id:"callback-best-practices",children:"Callback Best Practices"}),"\n",(0,l.jsxs)(r.ol,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Keep callbacks fast"}),": Don't block in callbacks"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Avoid heavy computation"}),": Use threads or async for heavy work"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Handle errors"}),": Wrap callbacks in try-except"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Don't modify node state carelessly"}),": Be thread-safe"]}),"\n"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'def safe_callback(self, msg):\r\n    """Safe callback with error handling."""\r\n    try:\r\n        # Process message\r\n        result = self.process_message(msg)\r\n        self.get_logger().info(f\'Processed: {result}\')\r\n    except Exception as e:\r\n        self.get_logger().error(f\'Callback error: {e}\')\n'})}),"\n",(0,l.jsx)(r.h3,{id:"callback-threading",children:"Callback Threading"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'import threading\r\n\r\nclass ThreadedCallbackNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'threaded_callback_node\')\r\n        \r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            \'topic\',\r\n            self.subscription_callback,\r\n            10\r\n        )\r\n        \r\n        self.work_queue = queue.Queue()\r\n        self.worker_thread = threading.Thread(target=self.worker)\r\n        self.worker_thread.start()\r\n    \r\n    def subscription_callback(self, msg):\r\n        """Fast callback - just queue work."""\r\n        self.work_queue.put(msg)\r\n    \r\n    def worker(self):\r\n        """Worker thread for heavy processing."""\r\n        while True:\r\n            try:\r\n                msg = self.work_queue.get(timeout=1.0)\r\n                # Heavy processing here\r\n                self.process_heavy_work(msg)\r\n            except queue.Empty:\r\n                continue\n'})}),"\n",(0,l.jsx)(r.h2,{id:"parameters",children:"Parameters"}),"\n",(0,l.jsx)(r.p,{children:"Parameters allow runtime configuration of nodes without code changes."}),"\n",(0,l.jsx)(r.h3,{id:"declaring-parameters",children:"Declaring Parameters"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"class ParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('parameter_node')\r\n        \r\n        # Declare parameters with default values\r\n        self.declare_parameter('my_string', 'default_value')\r\n        self.declare_parameter('my_int', 42)\r\n        self.declare_parameter('my_double', 3.14)\r\n        self.declare_parameter('my_bool', True)\r\n        \r\n        # Get parameter values\r\n        my_string = self.get_parameter('my_string').get_parameter_value().string_value\r\n        my_int = self.get_parameter('my_int').get_parameter_value().integer_value\r\n        \r\n        self.get_logger().info(f'String: {my_string}, Int: {my_int}')\n"})}),"\n",(0,l.jsx)(r.h3,{id:"parameter-descriptors",children:"Parameter Descriptors"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"from rclpy.parameter import ParameterDescriptor\r\nfrom rcl_interfaces.msg import ParameterType\r\n\r\nclass DescribedParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('described_parameter_node')\r\n        \r\n        # Parameter with description\r\n        descriptor = ParameterDescriptor(\r\n            description='A string parameter for configuration',\r\n            type=ParameterType.PARAMETER_STRING,\r\n            read_only=False\r\n        )\r\n        \r\n        self.declare_parameter('config_string', 'default', descriptor)\n"})}),"\n",(0,l.jsx)(r.h3,{id:"parameter-constraints",children:"Parameter Constraints"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"from rcl_interfaces.msg import IntegerRange, FloatingPointRange\r\n\r\nclass ConstrainedParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('constrained_parameter_node')\r\n        \r\n        # Integer with range\r\n        int_descriptor = ParameterDescriptor(\r\n            description='Integer between 0 and 100',\r\n            integer_range=[IntegerRange(from_value=0, to_value=100, step=1)]\r\n        )\r\n        self.declare_parameter('my_int', 50, int_descriptor)\r\n        \r\n        # Double with range\r\n        double_descriptor = ParameterDescriptor(\r\n            description='Double between 0.0 and 1.0',\r\n            floating_point_range=[FloatingPointRange(from_value=0.0, to_value=1.0, step=0.1)]\r\n        )\r\n        self.declare_parameter('my_double', 0.5, double_descriptor)\n"})}),"\n",(0,l.jsx)(r.h3,{id:"setting-parameters-at-runtime",children:"Setting Parameters at Runtime"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"class DynamicParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('dynamic_parameter_node')\r\n        \r\n        self.declare_parameter('threshold', 10.0)\r\n        \r\n        # Service to update parameter\r\n        self.service = self.create_service(\r\n            SetParameters,\r\n            'set_parameters',\r\n            self.set_parameters_callback\r\n        )\r\n    \r\n    def set_parameters_callback(self, request, response):\r\n        \"\"\"Update parameters via service.\"\"\"\r\n        for param in request.parameters:\r\n            if param.name == 'threshold':\r\n                self.set_parameters([param])\r\n                response.results.append(\r\n                    SetParametersResult(successful=True)\r\n                )\r\n        return response\n"})}),"\n",(0,l.jsx)(r.h2,{id:"executors",children:"Executors"}),"\n",(0,l.jsx)(r.p,{children:"Executors control how callbacks are executed. Understanding executors is key to performance."}),"\n",(0,l.jsx)(r.h3,{id:"single-threaded-executor",children:"Single-Threaded Executor"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"from rclpy.executors import SingleThreadedExecutor\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    \r\n    node1 = Node1()\r\n    node2 = Node2()\r\n    \r\n    executor = SingleThreadedExecutor()\r\n    executor.add_node(node1)\r\n    executor.add_node(node2)\r\n    \r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        executor.shutdown()\r\n        rclpy.shutdown()\n"})}),"\n",(0,l.jsx)(r.h3,{id:"multi-threaded-executor",children:"Multi-Threaded Executor"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"from rclpy.executors import MultiThreadedExecutor\r\nimport threading\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    \r\n    node1 = Node1()\r\n    node2 = Node2()\r\n    \r\n    executor = MultiThreadedExecutor(num_threads=4)\r\n    executor.add_node(node1)\r\n    executor.add_node(node2)\r\n    \r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        executor.shutdown()\r\n        rclpy.shutdown()\n"})}),"\n",(0,l.jsx)(r.h3,{id:"custom-executor",children:"Custom Executor"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'from rclpy.executors import Executor\r\n\r\nclass CustomExecutor(Executor):\r\n    def __init__(self):\r\n        super().__init__()\r\n        self.priority_queue = []\r\n    \r\n    def spin_once(self, timeout_sec=None):\r\n        """Custom spin logic with priorities."""\r\n        # Implement custom callback scheduling\r\n        pass\n'})}),"\n",(0,l.jsx)(r.h2,{id:"complete-working-examples",children:"Complete Working Examples"}),"\n",(0,l.jsx)(r.h3,{id:"example-1-sensor-fusion-node",children:"Example 1: Sensor Fusion Node"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nSensor Fusion Node\r\n\r\nCombines data from multiple sensors with timers and callbacks.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float32\r\nfrom sensor_msgs.msg import Imu\r\nimport numpy as np\r\n\r\n\r\nclass SensorFusionNode(Node):\r\n    """Fuses data from multiple sensors."""\r\n    \r\n    def __init__(self):\r\n        super().__init__(\'sensor_fusion_node\')\r\n        \r\n        # Declare parameters\r\n        self.declare_parameter(\'fusion_rate\', 10.0)\r\n        self.declare_parameter(\'alpha\', 0.8)  # Filter coefficient\r\n        \r\n        # Get parameters\r\n        fusion_rate = self.get_parameter(\'fusion_rate\').value\r\n        self.alpha = self.get_parameter(\'alpha\').value\r\n        \r\n        # Subscribers\r\n        self.temp_sub = self.create_subscription(\r\n            Float32,\r\n            \'temperature\',\r\n            self.temp_callback,\r\n            10\r\n        )\r\n        \r\n        self.imu_sub = self.create_subscription(\r\n            Imu,\r\n            \'imu\',\r\n            self.imu_callback,\r\n            10\r\n        )\r\n        \r\n        # Publisher\r\n        self.fused_pub = self.create_publisher(\r\n            Float32,\r\n            \'fused_data\',\r\n            10\r\n        )\r\n        \r\n        # State\r\n        self.temperature = 0.0\r\n        self.acceleration = 0.0\r\n        self.fused_value = 0.0\r\n        \r\n        # Timer for fusion\r\n        timer_period = 1.0 / fusion_rate\r\n        self.timer = self.create_timer(timer_period, self.fusion_callback)\r\n        \r\n        self.get_logger().info(\'Sensor fusion node started\')\r\n    \r\n    def temp_callback(self, msg):\r\n        """Handle temperature data."""\r\n        self.temperature = msg.data\r\n    \r\n    def imu_callback(self, msg):\r\n        """Handle IMU data."""\r\n        # Extract acceleration magnitude\r\n        accel = msg.linear_acceleration\r\n        self.acceleration = np.sqrt(\r\n            accel.x**2 + accel.y**2 + accel.z**2\r\n        )\r\n    \r\n    def fusion_callback(self):\r\n        """Fuse sensor data."""\r\n        # Simple weighted fusion\r\n        self.fused_value = (\r\n            self.alpha * self.fused_value +\r\n            (1 - self.alpha) * (self.temperature + self.acceleration)\r\n        )\r\n        \r\n        # Publish fused data\r\n        msg = Float32()\r\n        msg.data = self.fused_value\r\n        self.fused_pub.publish(msg)\r\n        \r\n        self.get_logger().info(\r\n            f\'Fused: {self.fused_value:.2f} \'\r\n            f\'(T: {self.temperature:.2f}, A: {self.acceleration:.2f})\'\r\n        )\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = SensorFusionNode()\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info(\'Shutting down...\')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,l.jsx)(r.h3,{id:"example-2-state-machine-node",children:"Example 2: State Machine Node"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nState Machine Node\r\n\r\nDemonstrates state management with timers and callbacks.\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom enum import Enum\r\n\r\n\r\nclass RobotState(Enum):\r\n    IDLE = 'idle'\r\n    MOVING = 'moving'\r\n    STOPPED = 'stopped'\r\n    ERROR = 'error'\r\n\r\n\r\nclass StateMachineNode(Node):\r\n    \"\"\"Node with state machine logic.\"\"\"\r\n    \r\n    def __init__(self):\r\n        super().__init__('state_machine_node')\r\n        \r\n        # State\r\n        self.state = RobotState.IDLE\r\n        \r\n        # Publisher\r\n        self.state_pub = self.create_publisher(\r\n            String,\r\n            'robot_state',\r\n            10\r\n        )\r\n        \r\n        # Timer for state updates\r\n        self.timer = self.create_timer(0.5, self.state_callback)\r\n        \r\n        # Subscriber for commands\r\n        self.cmd_sub = self.create_subscription(\r\n            String,\r\n            'command',\r\n            self.command_callback,\r\n            10\r\n        )\r\n        \r\n        self.get_logger().info('State machine node started')\r\n    \r\n    def command_callback(self, msg):\r\n        \"\"\"Handle commands.\"\"\"\r\n        cmd = msg.data.lower()\r\n        \r\n        if cmd == 'start' and self.state == RobotState.IDLE:\r\n            self.state = RobotState.MOVING\r\n            self.get_logger().info('State: IDLE -> MOVING')\r\n        elif cmd == 'stop' and self.state == RobotState.MOVING:\r\n            self.state = RobotState.STOPPED\r\n            self.get_logger().info('State: MOVING -> STOPPED')\r\n        elif cmd == 'reset' and self.state == RobotState.STOPPED:\r\n            self.state = RobotState.IDLE\r\n            self.get_logger().info('State: STOPPED -> IDLE')\r\n        else:\r\n            self.get_logger().warn(f'Invalid command: {cmd} in state: {self.state}')\r\n    \r\n    def state_callback(self):\r\n        \"\"\"Publish current state.\"\"\"\r\n        msg = String()\r\n        msg.data = self.state.value\r\n        self.state_pub.publish(msg)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = StateMachineNode()\r\n    \r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        node.get_logger().info('Shutting down...')\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,l.jsx)(r.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,l.jsx)(r.h3,{id:"logging-configuration",children:"Logging Configuration"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"# Set log level\r\nself.get_logger().set_level(rclpy.logging.LoggingSeverity.DEBUG)\r\n\r\n# Log with different levels\r\nself.get_logger().debug('Debug message')\r\nself.get_logger().info('Info message')\r\nself.get_logger().warn('Warning message')\r\nself.get_logger().error('Error message')\n"})}),"\n",(0,l.jsx)(r.h3,{id:"clock-and-time",children:"Clock and Time"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"# Get current time\r\nnow = self.get_clock().now()\r\nself.get_logger().info(f'Current time: {now}')\r\n\r\n# Create duration\r\nfrom rclpy.duration import Duration\r\nduration = Duration(seconds=5, nanoseconds=0)\r\n\r\n# Sleep\r\nimport time\r\ntime.sleep(1.0)\n"})}),"\n",(0,l.jsx)(r.h3,{id:"node-namespaces",children:"Node Namespaces"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"# Create node in namespace\r\nnode = Node('my_node', namespace='robot1')\r\n\r\n# Topics will be: /robot1/my_topic\n"})}),"\n",(0,l.jsx)(r.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsxs)(r.ol,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Always initialize rclpy"}),": Call ",(0,l.jsx)(r.code,{children:"rclpy.init()"})," before creating nodes"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Clean shutdown"}),": Always call ",(0,l.jsx)(r.code,{children:"rclpy.shutdown()"})," in finally block"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Handle exceptions"}),": Wrap callbacks in try-except"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Use parameters"}),": Don't hardcode values"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Manage timers"}),": Cancel timers when not needed"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.strong,{children:"Thread safety"}),": Be careful with shared state in callbacks"]}),"\n"]}),"\n",(0,l.jsx)(r.h2,{id:"common-errors-and-solutions",children:"Common Errors and Solutions"}),"\n",(0,l.jsx)(r.h3,{id:"error-1-rclpyinit-not-called",children:'Error 1: "rclpy.init() not called"'}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"# Problem\r\nnode = MyNode()  # Error!\r\n\r\n# Solution\r\nrclpy.init(args=args)\r\nnode = MyNode()\n"})}),"\n",(0,l.jsx)(r.h3,{id:"error-2-timer-callback-blocking",children:'Error 2: "Timer callback blocking"'}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"# Problem: Heavy work in callback\r\ndef timer_callback(self):\r\n    heavy_computation()  # Blocks other callbacks\r\n\r\n# Solution: Use threads or async\r\ndef timer_callback(self):\r\n    threading.Thread(target=heavy_computation).start()\n"})}),"\n",(0,l.jsx)(r.h3,{id:"error-3-parameter-not-declared",children:'Error 3: "Parameter not declared"'}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-python",children:"# Problem\r\nvalue = self.get_parameter('my_param').value  # Error!\r\n\r\n# Solution\r\nself.declare_parameter('my_param', default_value)\r\nvalue = self.get_parameter('my_param').value\n"})}),"\n",(0,l.jsx)(r.h2,{id:"exercises",children:"Exercises"}),"\n",(0,l.jsx)(r.h3,{id:"exercise-1-parameter-driven-node",children:"Exercise 1: Parameter-Driven Node"}),"\n",(0,l.jsx)(r.p,{children:"Create a node with multiple parameters that control its behavior (publish rate, message content, etc.)."}),"\n",(0,l.jsx)(r.h3,{id:"exercise-2-multi-timer-coordination",children:"Exercise 2: Multi-Timer Coordination"}),"\n",(0,l.jsx)(r.p,{children:"Create a node with multiple timers that coordinate (e.g., one timer collects data, another processes it)."}),"\n",(0,l.jsx)(r.h3,{id:"exercise-3-callback-queue-management",children:"Exercise 3: Callback Queue Management"}),"\n",(0,l.jsx)(r.p,{children:"Implement a node that manages callback execution with priorities."}),"\n",(0,l.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,l.jsx)(r.p,{children:"Continue learning:"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.a,{href:"/physical-ai-textbook/docs/module-01-ros2/urdf-basics",children:"Chapter 5: URDF Basics"})," - Create robot models"]}),"\n",(0,l.jsxs)(r.li,{children:[(0,l.jsx)(r.a,{href:"/physical-ai-textbook/docs/module-01-ros2/launch-files",children:"Chapter 6: Launch Files"})," - Orchestrate multiple nodes"]}),"\n"]})]})}function m(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>i});var a=n(6540);const l={},t=a.createContext(l);function s(e){const r=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),a.createElement(t.Provider,{value:r},e.children)}}}]);